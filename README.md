# Custom Encryption Method by Subhan

This repository contains a **fully custom multi-stage encryption algorithm** developed from scratch in Python. The encryption scheme is not a simple wrapper on standard algorithms, but a unique sequence that blends classical ciphers, indexed keys, matrix transformations, and deterministic randomization—making it highly original, educational, and nontrivial to break without knowing its exact structure.

---

## Overview & Motivation

This project is a deep, hands-on exploration of cryptography. The goal was to design a **bespoke encryption system** that:
- Avoids using any single standard cipher directly.
- Combines multi-layered cryptographic ideas: substitution, transposition, and non-linear key evolution.
- Is fully reversible and deterministic with a single key.
- Demonstrates how custom ciphers can be created and chained for educational, research, or novelty purposes.

**Warning:**  
No guarantees are made regarding real-world security. This scheme has not been professionally audited and is intended for educational and exploratory use only.

---

## Encryption Algorithm: Step-by-Step

### 1. Text Preprocessing
- **Input:** Arbitrary plaintext.
- **Process:**  
  - Removes all non-alphabetic characters except numbers.
  - Records the original positions of spaces and special characters so they can be restored after decryption.

---

### 2. Vigenère Encryption with Fibonacci-Indexed Key
- Instead of using the whole key, only the characters at **Fibonacci sequence positions** in the key are extracted.
- This “Fibonacci key” is used to perform a Vigenère cipher (modulo 26 for letters, or modulo 36 for alphanumeric).
- **Result:** First layer of substitution, with a key that is non-trivial to guess without knowing the Fibonacci step.

#### Example:
- Key: `THISISALONGKEYWITHOUTNUMBERS`
- Fibonacci-indexed chars: `T`, `H`, `I`, `S`, `A`, `L`, ...

---

### 3. Non-Fibonacci Key and ASCII Addition
- The characters from the original key that are **not** at Fibonacci positions are extracted (“non-Fib key”).
- A new key is generated by **adding the ASCII values** (modulo 26) of each character in the non-Fib key to the corresponding character in the Vigenère-encrypted text.
- This produces a “combined key” with strong diffusion, used for the next cipher.

---

### 4. Playfair Matrix Construction and Encryption
- The combined key is used to construct a **5x5 Playfair cipher matrix**.
- The Vigenère-encrypted text is then encrypted using Playfair rules:
  - Digraphs are formed.
  - Substitutions are made row/column/rectangle-wise.
  - All “J”s are replaced with “I” (standard Playfair), and their positions are tracked for accurate decryption.

---

### 5. Deterministic Randomization
- The Playfair output is **shuffled using Python's random module**, with the original key as the random seed.
- This makes the ciphertext non-sequential and adds a layer of transposition.
- During decryption, the same key is used to deterministically “derandomize” the text.

---

### 6. Decryption Process
- The operations are reversed in the following order:
  1. Derandomize the text.
  2. Playfair decrypt (restoring “J”s as needed).
  3. Vigenère decrypt (using Fibonacci-indexed key).
  4. Reinserts spaces and special characters to reconstruct the original message.

---

## Security Properties & Unique Features

- **Multi-layered:** Combines substitution (Vigenère), matrix substitution (Playfair), and transposition (randomization).
- **Indexed keys:** Splits key into two functional parts (Fibonacci and non-Fibonacci), dramatically increasing key entropy.
- **Nonlinear key evolution:** ASCII addition for new key mixes plaintext and key in a nonstandard way.
- **Full reversibility:** Every transformation is tracked, including character substitutions and space positions.
- **Seeded randomization:** Transposition is deterministic and fully reversible with the key.
- **Educational value:** Demonstrates building custom ciphers from primitives, chaining operations, and tracking state for decryption.

---

## Usage

1. **Run the script** directly with Python 3:

   ```bash
   python nis_1.py
   ```

2. **Customize inputs:**  
   - The script contains hardcoded plaintext and key variables at the bottom.  
   - Change these to experiment with different messages and keys.

3. **Output:**  
   - Step-by-step prints of each encryption layer.
   - Final encrypted and decrypted text visible in the console.

---

## Example Workflow

```python
plaintext = "I HAVE 22 LOVE STORIES"
key = "THISISALONGKEYWITHOUTNUMBERS"

# Preprocessing
space_positions, plaintext_no_spaces = preprocess_text(plaintext)

# Vigenère encryption using Fibonacci-indexed key
vigenere_encrypted = encrypt_vigenere(plaintext_no_spaces, key)

# Generate non-Fibonacci key and combine with Vigenère output
non_fib_key = non_fibonacci_indexed_chars(key)
ascii_added_key = add_ascii_chars(vigenere_encrypted, non_fib_key)

# Playfair matrix and encryption
matrix = generate_playfair_matrix(ascii_added_key)
playfair_encrypted, j_to_i_positions = encrypt_playfair(matrix, vigenere_encrypted)

# Randomization
randomized_text = randomize_text(playfair_encrypted, key)

# Decryption (reverse all steps)
derandomized_text = derandomize_text(randomized_text, key)
playfair_decrypted = decrypt_playfair(matrix, derandomized_text, j_to_i_positions)
vigenere_decrypted = decrypt_vigenere(playfair_decrypted, key)
final_decrypted_text_with_spaces = add_spaces_to_text(vigenere_decrypted, space_positions)
```

---

## Repository Contents

- `nis_1.py` — Main implementation of the encryption and decryption workflow.
- `tempCodeRunnerFile.py` — Temporary file, not required for core functionality.

---

## API & Functions

- `preprocess_text(text)`: Cleans input, records space positions.
- `fibonacci_indexed_chars(key)`: Returns key chars at Fibonacci indices.
- `non_fibonacci_indexed_chars(key)`: Returns other key chars.
- `encrypt_vigenere(plaintext, key)`: Vigenère cipher with Fibonacci key.
- `decrypt_vigenere(ciphertext, key)`: Reverses Vigenère.
- `add_ascii_chars(vigenere_output, non_fib_key)`: Produces Playfair key.
- `generate_playfair_matrix(key)`: Builds 5x5 matrix.
- `encrypt_playfair(matrix, text)`: Playfair encryption.
- `decrypt_playfair(matrix, text, j_to_i_positions)`: Playfair decryption.
- `randomize_text(text, seed)`: Deterministically shuffles text.
- `derandomize_text(text, seed)`: Restores order.
- `add_spaces_to_text(text, space_positions)`: Recovers spaces.

---

## Disclaimer

This encryption method was created by Subhan as a personal learning project.  
It is **not** intended for securing sensitive data, nor has it been professionally reviewed.  
Use for educational, experimental, or novelty purposes only.

---

## License

Distributed under the MIT License.

---
